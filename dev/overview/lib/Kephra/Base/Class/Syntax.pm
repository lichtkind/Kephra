use v5.16;
use warnings;

package Kephra::Base::Class::Syntax;

use Kephra::Base::Class::Builder;

sub import    {} # establish new keywords
sub unimport  {} # remove them

1;

__END__

class C;                                                # starts a class definition, 


type name => {help => 'description what is checked', 
              code => '...', 
              default => val,
            ? parent => type_name,
            ? parameter => 'name' | { type => 'name',   # just to create parametric type
                                    ? name => '',       # overwerite name of parameter type
                                    ? default => ..},   # overwrite default value of parameter type


argument name => {help => 'description', 
                  type => 'name', 
            ?     attribute => 'name'};                 # argument is relative to what attribute


attribute name => {help => '',                          # help = long name
                   type => 'name',                      # normal data type or class type, whis is not a class itself
                   get  => {settername => scope, ..},   # scope: access, private, public # -name = autogenerated getter/setter name
                   set  => {gettername => scope, ..}};  # scope: access, private, public # -name = autogenerated getter/setter name
           ?    default => $val|,                       # default value when its different from the type ones
           ? build_lazy => $val|,                       # code to build default value lazily (none lazy can be done in constructor)

delegating attribute name  => {help => '',                 # help = long name
                              class => 'Kephra::...',      # class of attribute (has to be a KBOS class)
                           delegate => { dname => 'scope', # methods that have access to atribute # -name = automatically delegated method to attribute
                                        -dname => 'scope', # map public method dname from attr ~class to parent class
                                         dname => {rename =>'orig', scope =>'scope',}      # redirect method 'dname' of class to method 'orig' of attribute
                 ?          default => [],                 # default args to construct attribute object
                 ?       build_lazy => 1|[],               # args to build lazily

wrapping attribute name => { help  => '',                  # short explaining text for better ~errormsg
                            class  => 'Kephra::...',       # class of attribute (can be any)
                            wrap   => { wname => 'scope'   # claim this to be implemented wrapper method as belonging to this attribute
                    ?      default => '',                  # code to build attr object (without classname)
                    ?   build_lazy => 1|'....',            # code to build attr lazily


constructor new     (sig) {@_ = $self, $args, $attr};   # build method is called by new             # $self has only here access to getter and setter in build scope
destructor demolish (sig) {@_ = $self, $args, $attr};   # canonical name for destructor method     # called autmatically or by hand                  # build scope

(g|s)etter [method] name (sig) {($self, $args, $attr->name/help/get/set/reset) = @_};                          # scope determined by attr def
delegator [method] name (sig) {$self, $args, $attr->name/help/get/class) = @_}
wrapper [method] name (sig) {$self, $args, $attr->name/help/get/class) = @_}

[public] [multi] method name (sig) {$self, $args) = @_}    # methods are per default public, every multi has to be named multi
 private [multi] method name (sig) {$self, $args) = @_}    # private methods are only callable inside the class
                                                           # multi can be public, private, accessor - all of the multis has to be marked as such 

                             (sig) = (type parametername, ~parameter, array of str c, index of attr list i - type parametername  --> return type)
                                     #  required parameter                                                   optional parameter


ACCESS RULES: 

see:              any obj ref     inside any       g/setter     constructor
                  everywhere   method of class   deleg./wrap.  deconstructor
public method
and accessors          *              *               *              *
in public scope

private method or                     *               *              *
private g/s

access scope g/s                                      *              *

build scope  g/s                                                     *