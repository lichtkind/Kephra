#!/usr/bin/perl -w
use v5.20;
use warnings;
use experimental qw/switch/;
use Test::More tests => 70;

BEGIN { unshift @INC, 'lib', '../lib', '.', 't'}
require Kephra::Base::Class::Definition::Attribute::Data;
require Kephra::Base::Data::Type;

my $class = 'Kephra::Base::Class::Definition::Attribute::Data';
my $req_properies = {name => 'name', help => 'help', type => 'int'};
sub mk_attr_def {Kephra::Base::Class::Definition::Attribute::Data->new(@_)}


my $def = mk_attr_def({%$req_properies, get => 'get'});
is( ref $def,                                               $class,        'created first data attribute definition object with minimal properties');
is( $def->get_kind,                                         'data',        'check getter of "kind" property');
is( $def->get_help,                                         'help',        'check getter of "help" property');
is( $def->get_type,                                          'int',        'check getter of "type" property');
is( $def->get_init,                                          undef,        'check getter of "init" property');
is( $def->get_build,                                         undef,        'check getter of "build" property');
is( $def->is_lazy,                                               0,        'check getter of "lazy" property');
is( $def->accessor_names,                                        1,        'attribute has only one getter');
is( ($def->accessor_names)[0],                               'get',        'got the right getter name');
is( ref $def->auto_accessors,                               'HASH',        'getter of "auto methods" property return HASH');
is( keys %{$def->auto_accessors},                                0,        'data attribute definition has no autogenerated methods');
is( $def->get_dependency,                                    undef,        'check getter of "dependency" property');
is( $def->get_requirement,                                   undef,        'check getter of "requirement" property');
is( $def->check_type(Kephra::Base::Data::Type::standard()),     '',        'call check_type to ensure existance of type and default value');
is( $def->get_init,                                              0,        'default value of data type ws inserted');

$def = mk_attr_def({%$req_properies, get => 'get', set => 'set'});
is( $def->accessor_names,                                        2,        'attribute has now two accessors');
is( 'get' ~~ [$def->accessor_names],                             1,        '"get" is one');
is( 'set' ~~ [$def->accessor_names],                             1,        '"set" is the other');

$def = mk_attr_def({%$req_properies, get => ['get1', 'get2']});
is( $def->accessor_names,                                        2,        'attribute has now two getter');
is( 'get1' ~~ [$def->accessor_names],                            1,        '"get1" is one');
is( 'get2' ~~ [$def->accessor_names],                            1,        '"get2" is the other');

$def = mk_attr_def({%$req_properies, get => ['get1', 'get2'], set => ['set1', 'set2']});
is( $def->accessor_names,                                        4,        'attribute has now four accessors');
is( 'get1' ~~ [$def->accessor_names],                            1,        '"get1" is one');
is( 'get2' ~~ [$def->accessor_names],                            1,        '"get2" is the other');
is( 'set1' ~~ [$def->accessor_names],                            1,        '"set1" is one');
is( 'set2' ~~ [$def->accessor_names],                            1,        '"set2" is the fourth');

$def = mk_attr_def({%$req_properies, auto_get => {getter => 'public'}});
is( ref $def,                                               $class,        'created next data attribute definition object with autogenerated getter');
is( $def->accessor_names,                                        0,        'no reguar attribute accessors this time');
is( ($def->accessor_names)[0],                               undef,        'the only name is undef');
is( ref $def->auto_accessors,                               'HASH',        'getter of "auto methods" property return HASH');
is( ref $def->auto_accessors->{'getter'},                   'HASH',        'definition of the autogenerated getter exists');
is( $def->auto_accessors->{'getter'}{'get'},              'public',        'autogenerated getter is public');

$def = mk_attr_def({%$req_properies, auto_get => {get => 'public'}, auto_set => {set => 'private'}});
is( ref $def,                                               $class,        'created data attribute definition object with autogenerated getter and setter');
is( $def->accessor_names,                                        0,        'no reguar attribute accessors this time');
is( ($def->accessor_names)[0],                               undef,        'the only name is undef');
is( ref $def->auto_accessors,                               'HASH',        'getter of "auto methods" property return HASH');
is( ref $def->auto_accessors->{'get'},                      'HASH',        'definition of the autogenerated getter exists');
is( $def->auto_accessors->{'get'}{'get'},                 'public',        'got the scope of the autogenerated getter');
is( ref $def->auto_accessors->{'set'},                      'HASH',        'definition of the autogenerated setter exists');
is( $def->auto_accessors->{'set'}{'set'},                'private',        'got the scope of the autogenerated setter');


$def = mk_attr_def({%$req_properies, auto_get => {gset => 'public'}, auto_set => {gset => 'private'}});
is( ref $def->auto_accessors,                               'HASH',        'getter of "auto methods" property return HASH');
is( ref $def->auto_accessors->{'gset'},                     'HASH',        'definition of the autogenerated getter setter exists');
is( $def->auto_accessors->{'gset'}{'get'},                'public',        'got the scope of the autogenerated detter part');
is( $def->auto_accessors->{'gset'}{'set'},               'private',        'got the scope of the autogenerated setter part');

$def = mk_attr_def({%$req_properies, get => 'get', init => 1});
is( ref $def,                                               $class,        'created data attribute definition with initial value');
is( $def->get_init,                                              1,        'got "init" value');
is( $def->get_build,                                         undef,        'no "build" property');
is( $def->check_type(Kephra::Base::Data::Type::standard()),     '',        'call check_type to ensure existance of type and default value');
is( $def->get_init,                                              1,        'original "init" value was not changed');

$def = mk_attr_def({%$req_properies, get => 'get', build => 'das'});
is( ref $def,                                               $class,        'created data attribute definition with code to "build" initial value');
is( $def->get_init,                                          undef,        'no "init" value');
is( $def->get_build,                                         'das',        'got "build" code');
is( $def->check_type(Kephra::Base::Data::Type::standard()),     '',        'call check_type to ensure existance of type and default value');
is( $def->get_init,                                          undef,        'no "init" value inserted whe there is build code');
is( $def->is_lazy,                                               0,        'build was not "lazy"');

$def = mk_attr_def({%$req_properies, get => 'get', lazy_build => 'das'});
is( ref $def,                                               $class,        'created data attribute definition with lazily evaluated code to "build" initial value');
is( $def->get_init,                                          undef,        'no "init" value');
is( $def->get_build,                                         'das',        'got "build" code');
is( $def->check_type(Kephra::Base::Data::Type::standard()),     '',        'call check_type to ensure existance of type and default value');
is( $def->get_init,                                          undef,        'no "init" value inserted whe there is build code');
is( $def->is_lazy,                                               1,        'build is "lazy"');

ok(not (ref mk_attr_def([])),                                              'new needs an hash ref');
ok(not (ref mk_attr_def({name => 'name', help => 'help', get => 'get'})),  '"type" property is missing');
ok(not (ref mk_attr_def({name => 'name', type => 'int',  get => 'get'})),  '"help" property is missing');
ok(not (ref mk_attr_def({help => 'help', type => 'int',  get => 'get'})),  '"name" property is missing');
ok(not (ref mk_attr_def({%$req_properies, get => 'get', boink =>1})),      '"fantasy" property is too much');
ok(not (ref mk_attr_def({%$req_properies, get => {get => 1}})),            '"get" property has to be an ARRAY');
ok(not (ref mk_attr_def({%$req_properies, get => 'a', set => {get => 1}})),'"set" property has to be an ARRAY');
$req_properies = {name => 'name', help => 'help', type => 'int', get => 'get'};
ok(not (ref mk_attr_def({%$req_properies, init => 1, build => 1})),        'only one init method is allowed');
ok(not (ref mk_attr_def({%$req_properies, laty_build => 1, build => 1})),  'build attribute lazily or not, not both');

exit 0;
