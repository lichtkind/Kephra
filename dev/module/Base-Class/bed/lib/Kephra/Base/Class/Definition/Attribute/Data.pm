use v5.20;
use warnings;

# data structure holding a definition of a raw data holding KBOS attribute

package Kephra::Base::Class::Definition::Attribute::Data;
our $VERSION = 1.3;
my $kind = 'data';
################################################################################
sub new {        # ~pkg %attr_def            --> ._ | ~errormsg
    my ($pkg, $attr_def) = (@_);
    my $self = {methods => [], auto => {}, lazy => 0};
    return "need a property hash to create a data attribute definition" unless ref $attr_def eq 'HASH';
    my $error_start = "$kind attribute ".(exists $attr_def->{name} ? $attr_def->{name} : '');
    for (qw/name help type/) {
        return "$error_start lacks property '$_'" unless exists $attr_def->{$_};
        return "$error_start property '$_' can not be a reference"  if ref $attr_def->{$_};
        return "$error_start property '$_' can not be empty"  unless $attr_def->{$_};
        $self->{$_} = delete $attr_def->{$_};
    }
    if    (exists $attr_def->{'default'})   {$self->{'default'} = delete $attr_def->{'default'} }
    elsif (exists $attr_def->{'build'})     {$self->{'build'}   = delete $attr_def->{'build'} }
    elsif (exists $attr_def->{'lazy_build'}){$self->{'build'}   = delete $attr_def->{'lazy_build'}; $self->{'lazy'} = 1; }

    return "$error_start lacks property 'get' or 'auto_get' to define a getter method" unless exists $attr_def->{'get'} or exists $attr_def->{'auto_get'};
    return "$error_start property 'get' has to be string with valid getter method name or an arry of such names"
        if exists $attr_def->{'get'} and ref $attr_def->{'get'} and ref $attr_def->{'get'} ne 'ARRAY';
    return "$error_start property 'set' has to be string with valid setter method name or an arry of such names"
        if exists $attr_def->{'set'} and ref $attr_def->{'set'} and ref $attr_def->{'set'} ne 'ARRAY';
    push @{$self->{'methods'}}, @{delete $attr_def->{'get'}} if ref $attr_def->{'get'} eq 'ARRAY';
    push @{$self->{'methods'}},   delete $attr_def->{'get'}  if not ref $attr_def->{'get'} and exists $attr_def->{'get'};
    push @{$self->{'methods'}}, @{delete $attr_def->{'set'}} if ref $attr_def->{'set'} eq 'ARRAY';
    push @{$self->{'methods'}},   delete $attr_def->{'set'}  if not ref $attr_def->{'set'} and exists $attr_def->{'set'};

    return "$error_start property 'auto_get' has to be defined by an hash: auto_get => {method => scope} or auto_get => method (default access scope)" 
        if exists $attr_def->{'auto_get'} and ref $attr_def->{'auto_get'} and ref $attr_def->{'auto_get'} ne 'HASH';
    return "$error_start property 'auto_set' has to be defined by an hash: auto_set => {method => scope} or auto_set => method (default access scope)" 
        if exists $attr_def->{'auto_set'} and ref $attr_def->{'auto_set'} and ref $attr_def->{'auto_set'} ne 'HASH';
    $self->{'auto'} = delete $attr_def->{'auto_get'} if ref $attr_def->{'auto_get'} eq 'HASH';
    for (keys %{$self->{'auto'}}){
        if (not ref $self->{'auto'}{$_})  { $self->{'auto'}{$_} = {get => ($self->{'auto'}{$_} or 'access')}   }
        else { return "autogenerated method '$_' of $error_start has an invalid definition. It has to be auto_get => {method => scope} or auto_set => {method => scope}" }
    }
    $self->{'auto'}{delete $attr_def->{'auto_get'}} = {get => 'access'} if exists $attr_def->{'auto_get'} and not ref $attr_def->{'auto_get'};
    $self->{'auto'}{delete $attr_def->{'auto_set'}}{'set'} = 'access' if exists $attr_def->{'auto_set'} and not ref $attr_def->{'auto_set'};
    if (ref $attr_def->{'auto_set'} eq 'HASH'){
        $self->{'auto'}{$_}{'set'} = $attr_def->{'auto_set'}{$_} for keys %{$attr_def->{'auto_set'}};
        delete $attr_def->{'auto_set'};
    }

    for (keys %$attr_def){ return "$error_start has the illegal, malformed or effectless property '$_'"  }
    bless $self;
}

sub check_type {    # ._       --> ~errormsg
    my $self = shift;
    for my $store (@_){
        next unless ref $store eq 'Kephra::Base::Data::Type::Store';
        if ($store->is_type_known( $self->{'type'} )){
            $self->{'default'} = $store->get_type( $self->{'type'} )->get_default_value() if not exists $self->{'default'} and not exists $self->{'build'};
            return '';
        }
    }
    return "data attribute $self->{name} has an unknown type: '$self->{type}'";
}
################################################################################
sub state        { {%{$_[0]}} }
sub restate      { bless shift}
################################################################################
sub get_kind     {$kind}
sub get_help     {$_[0]->{'help'}}
sub get_type     {$_[0]->{'type'}}
sub get_default  {$_[0]->{'default'}}
sub get_build    {$_[0]->{'build'}}
sub is_lazy      {$_[0]->{'lazy'}}
sub accessor_names {@{ $_[0]->{'methods'}} }
sub auto_accessors {$_[0]->{'auto'}} # name => scope | [getscope, setscope]
sub get_dependency  { undef }
sub get_requirement { undef }

1;
__END__

attribute name => {help => '',                            # help = long name/description for help messages
                   type => 'name',                        # normal data type or class type, whis is not a class itself
        |          get  => getter_name|[getter_name,..],  # method setter_name gets access to attribute
        |     auto_get  => {name => scope};               # autogenerated getter name
       ?           set  => setter_name|[setter_name,..];  # method setter_name gets access to attribute 
       ?      auto_set  => {name => scope};               # autogenerated setter name
       ?|       default => $val                           # default value when its different from the type ones
       ?|  [lazy_]build => 'code'                         # code to build default value (optionally lazy) (none lazy can also be done in constructor)
