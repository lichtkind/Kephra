#!/usr/bin/perl -w
use v5.20;
use warnings;
use Test::More tests => 87;

BEGIN { unshift @INC, 'lib', '../lib', '.', 't'}
require Kephra::Base::Class::Definition::Attribute::Delegating;

sub mk_attr_def {Kephra::Base::Class::Definition::Attribute::Delegating->new(@_)}
my $class = 'Kephra::Base::Class::Definition::Attribute::Delegating';
my $req_properies = {name => 'name', help => 'help', class => 'K::B::C', delegate => 'method'};

my $def = mk_attr_def({%$req_properies, default_args => ['C']});
is( ref $def,                                               $class,        'created first delegating attribute definition object');
is( $def->get_kind,                                   'delegating',        'check getter of "kind" property');
is( $def->get_help,                                         'help',        'check getter of "help" property');
is( ref $def->get_default_args,                            'ARRAY',        'check getter of "init" property');
is( @{$def->get_default_args},                                   1,        'got right amount of init values');
is( $def->get_default_args->[0],                               'C',        'got constructor init value');
is( $def->get_build_args,                                    undef,        'check getter of "build" property');
is( $def->is_lazy,                                               0,        'check getter of "lazy" property');
is( $def->accessor_names,                                        1,        'attribute has only one getter');
is( ($def->accessor_names)[0],                            'method',        'got the right delegator name');
is( ref $def->auto_accessors,                               'HASH',        'getter of "auto methods" property return HASH');
is( keys %{$def->auto_accessors},                                0,        'data attribute definition has no autogenerated methods');
is( $def->get_class,                                     'K::B::C',        'check getter of "class" property');

$def = mk_attr_def({%$req_properies, default_args => {a => 'b'}});
is( ref $def,                                               $class,        'created delegating attribute with hash of init args');
is( ref $def->get_default_args,                             'HASH',        'init args are HASH');
is( keys %{$def->get_default_args},                              1,        'HASH was has right amount of key');
is( $def->get_default_args->{'a'},                             'b',        'HASH contained right value');
is( $def->is_lazy,                                               0,        'attribute will be created eagerly');
is( $def->get_build_args,                                    undef,        'no code to build args');

$def = mk_attr_def({%$req_properies, lazy_args => {a => 'b'}});
is( ref $def,                                               $class,        'created delegating attribute with hash of init args');
is( ref $def->get_default_args,                             'HASH',        'init args are HASH');
is( keys %{$def->get_default_args},                              1,        'HASH was has right amount of key');
is( $def->get_default_args->{'a'},                             'b',        'HASH contained right value');
is( $def->is_lazy,                                               1,        'attribute will be created lazily');
is( $def->get_build_args,                                    undef,        'no code to build args');

$def = mk_attr_def({%$req_properies, build_args => ['C']});
is( ref $def,                                               $class,        'created delegating attribute with array of code to build args');
is( ref $def->get_build_args,                              'ARRAY',        'ARRAY of code snippets to build constructor args');
is( @{$def->get_build_args},                                     1,        'ARRAY had right amout of elements');
is( $def->get_build_args->[0],                                 'C',        'ARRAY element contained right value');
is( $def->is_lazy,                                               0,        'attribute will be created eagerly');
is( $def->get_default_args,                                  undef,        'no init values for constructor args');

$def = mk_attr_def({%$req_properies, build_args => {a => 'b'}});
is( ref $def,                                               $class,        'created delegating attribute with hash of code to build constructor args');
is( ref $def->get_build_args,                               'HASH',        'HASH of code snippets to build constructor args');
is( keys %{$def->get_build_args},                                1,        'HASH had right amout of elements');
is( $def->get_build_args->{'a'},                               'b',        'HASH element contained right value');
is( $def->is_lazy,                                               0,        'attribute will be created eagerly');
is( $def->get_default_args,                                  undef,        'no init values for constructor args');

$def = mk_attr_def({%$req_properies, lazy_build_args => {a => 'b'}});
is( ref $def,                                               $class,        'created delegating attribute with hash of code to build constructor args');
is( ref $def->get_build_args,                               'HASH',        'HASH of code snippets to build constructor args');
is( keys %{$def->get_build_args},                                1,        'HASH had right amout of elements');
is( $def->get_build_args->{'a'},                               'b',        'HASH element contained right value');
is( $def->is_lazy,                                               1,        'attribute will be created lazily');
is( $def->get_default_args,                                  undef,        'no init values for constructor args');

$def = mk_attr_def({%$req_properies, default_args => ['C'], delegate => [qw/a b/]});
is( ref $def,                                               $class,        'created delegating attribute definition with multiple delegators');
is( $def->accessor_names,                                        2,        'attribute has now two delegators');
is( ($def->accessor_names)[0],                                 'a',        'first delegator name is right');
is( ($def->accessor_names)[1],                                 'b',        'second delegator name is right');
is( keys %{$def->auto_accessors},                                0,        'no autogenerated methods');

$def = mk_attr_def({name => 'name', help => 'help', class => 'K::B::C', default_args => ['C'], auto_delegate => 'deleg', auto_get => 'getter'});
is( ref $def,                                               $class,        'created delegating attribute definition with with just one autogenerated delegator');
is( $def->accessor_names,                                        0,        'no hand written delegators');
is( keys %{$def->auto_accessors},                                2,        'and one auto generated');
is( ref $def->auto_accessors->{'deleg'},                    'HASH',        'its definition is a HASH');
is( $def->auto_accessors->{'deleg'}{'delegate_to'},        'deleg',        'auto delegator does not rename method');
is( $def->auto_accessors->{'deleg'}{'scope'},            'private',        'access scope is default for delegators');
is( ref $def->auto_accessors->{'getter'},                   'HASH',        'auto getter definition found');
is( $def->auto_accessors->{'getter'}{'get'},              'access',        'auto gettere defined by scalar name defaults to access scope');

$def = mk_attr_def({name => 'name', help => 'help', class => 'K::B::C', default_args => ['C'], delegate => [qw/a b/],
                    auto_delegate => {deleg => 'public', method => {scope => 'private', to => 'ation'}}, auto_get => {deleg => 'public'}});
is( ref $def,                                               $class,        'delegating attr def with with two autogenerated delegators with complex definition');
is( $def->get_kind,                                   'delegating',        '"kind" property is constant');
is( $def->get_help,                                         'help',        '"help" property gettter always works');
is( $def->get_class,                                     'K::B::C',        '"class" property');
is( $def->accessor_names,                                        2,        'no hand written delegators');
is( keys %{$def->auto_accessors},                                2,        'and one auto generated');
is( ref $def->auto_accessors->{'deleg'},                    'HASH',        'its definition is a HASH');
is( $def->auto_accessors->{'deleg'}{'delegate_to'},        'deleg',        'auto delegator does not rename method');
is( $def->auto_accessors->{'deleg'}{'scope'},             'public',        'scope was set to public');
is( $def->auto_accessors->{'deleg'}{'get'},               'public',        'auto getter ahs same name (as resolved cleanly)');
is( $def->auto_accessors->{'method'}{'delegate_to'},       'ation',        'auto delegator does not rename method');
is( $def->auto_accessors->{'method'}{'scope'},           'private',        'scope was set to public');

ok(not (ref mk_attr_def([])),                                              'new needs an hash ref to create delegating attribute definition');
ok(not (ref mk_attr_def({name => 'name', help => 'help', class => 'class', delegate => 'd'})),  'constructor args missing in attr definition');
ok(not (ref mk_attr_def({name => 'name', help => 'help', class => 'class', default_args => []})),       'delegator names are missing in attr definition');
ok(not (ref mk_attr_def({name => 'name', help => 'help', delegate => 'd',  default_args => []})),       'class name is missing in attr definition');
ok(not (ref mk_attr_def({name => 'name', class=> 'class',delegate => 'd',  default_args => []})),       'help string is missing in attr definition');
ok(not (ref mk_attr_def({help => 'help', class=> 'class',delegate => 'd',  default_args => []})),       'name string is missing in attr definition');
ok(not (ref mk_attr_def({%$req_properies, require => 'a', build_args => []})),  'added unspecced propery');
ok(not (ref mk_attr_def({%$req_properies, name => [], build_args => []})),      'attribute name can not be a reference');
ok(not (ref mk_attr_def({%$req_properies, name => '', build_args => []})),      'attribute name can not be a empty');
ok(not (ref mk_attr_def({%$req_properies, help => [], build_args => []})),      'attribute help string can not be a reference');
ok(not (ref mk_attr_def({%$req_properies, help => '', build_args => []})),      'attribute help string can not be a empty');
ok(not (ref mk_attr_def({%$req_properies, class => [], build_args => []})),     'attribute class can not be a reference');
ok(not (ref mk_attr_def({%$req_properies, class => '', build_args => []})),     'attribute class can not be a empty');
ok(not (ref mk_attr_def({%$req_properies, build_args => sub{}})),               'build code can not be already evaled');
ok(not (ref mk_attr_def({%$req_properies, default_args => qr//  })),            'init constructor args have to be in ARRAY or HASH');
ok(not (ref mk_attr_def({%$req_properies, default_args => [], build_args=>[] })),'constructor args were delivered in two ways');
ok(not (ref mk_attr_def({%$req_properies, default_args => [], lazy_args=>[] })), 'constructor args were delivered in two other ways');
ok(not (ref mk_attr_def({%$req_properies, lazy_build_args=>[],lazy_args=>[]})),  'too many constructor args were delivered in yet different way');
ok(not (ref mk_attr_def({%$req_properies, lazy_build_args=>[], build_args=>[]})),'too many constructor args were delivered in fouth different way');

exit 0;
