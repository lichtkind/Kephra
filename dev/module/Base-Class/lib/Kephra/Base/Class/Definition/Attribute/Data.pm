use v5.20;
use warnings;

package Kephra::Base::Class::Definition::Attribute::Data;
our $VERSION = 0.1;
################################################################################
sub new {        # ~pkg %attr_def            --> ._ | ~errormsg
    my ($pkg, $attr_def) = (@_);
    return "need a property hash to create a data attribute definition" unless ref $attr_def eq 'HASH';
    my $error_start = ("data attribute $attr_def->{name}");
    for (qw/delegate wrap class/){ return "$error_start has illegal property '$_'" if exists $attr_def->{$_} }


#    if (exists $attr_def->{'get'}) {$type_def = }
    return "$error_start has no associated getter method" if exists $attr_def->{'set'} and not exists $attr_def->{'get'};
    my $kind = (exists $attr_def->{'get'}) + (exists $attr_def->{'wrap'}) + (exists $attr_def->{'delegate'});
    my $build = (exists $attr_def->{'build'}) + (exists $attr_def->{'build_lazy'}) + (exists $attr_def->{'init'}) + (exists $attr_def->{'init_lazy'});
    return "$error_start needs an associated getter, delegator or wrapper method" if $kind == 0;
    return "$error_start can only have getter or delegator or wrapper" if $kind > 1;
    if (exists $attr_def->{'get'}){
        return "$error_start needs a to refer to a data 'type'" unless exists $attr_def->{'type'};
        return "$error_start can only have one 'init' or 'init_lazy' or 'build' or 'build_lazy' property" if $build > 1;
    } else {
        return "$error_start needs a to refer to a 'class'" unless exists $attr_def->{'class'};
        return "$error_start can only have one 'build' or 'build_lazy' property" if $build > 1;
        if (exists $attr_def->{'wrap'}){
            return "$error_start need to have a 'require' property" unless exists $attr_def->{'require'};
            return "$error_start wraps a none KBOS class and can not an init property " if exists $attr_def->{'init'} or exists $attr_def->{'init_lazy'} ;
        }
    }
    bless $attr_def;
}
################################################################################

sub get_kind  {'data'}
sub get_help  {$_[0]->{'help'}}
sub get_type  {$_[0]->{'type'}}
sub get_init  {$_[0]->{'init'}}
sub get_build {$_[0]->{'build'}}
sub is_lazy   {$_[0]->{'lazy'}}
sub accessor_names  {}
sub auto_accessors  {} # name => scope | [getscope, setscope]
sub get_dependency  { undef }
sub get_requirement { undef }


1;

__DATA__

attribute name => {help => '',                           # help = long name/description for help messages
                   type => 'name',                       # normal data type or class type, whis is not a class itself
                   get  => setter_name|[setter_name,..], # method setter_name gets access to attribute # -name = autogenerated getter/setter name
         ?         set  => getter_name|[getter_name,..]; # method getter_name gets access to attribute # -name = autogenerated getter/setter name
         ?  init[_lazy] => $val                          # initial value when its different from the type ones
         ? build[_lazy] => 'code'                        # code to build default value (optionally lazy) (none lazy can also be done in constructor)

